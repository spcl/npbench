/hppfs/work/pr28fi/di38jil/npb-shared/npb-lrz/npbench/benchmarks/polybench/covariance/covariance_numba_o.py:17: NumbaPerformanceWarning: '@' is faster on contiguous arrays, called on (Array(float64, 1, 'A', False, aligned=True), Array(float64, 2, 'A', False, aligned=True))
  cov[i:M, i] = cov[i, i:M] = data[:, i] @ data[:, i:M] / (float_n - 1.0)
/hppfs/work/pr28fi/di38jil/npb-shared/npb-lrz/npbench/benchmarks/polybench/covariance/covariance_numba_op.py:17: NumbaPerformanceWarning: '@' is faster on contiguous arrays, called on (Array(float64, 1, 'A', False, aligned=True), Array(float64, 2, 'A', False, aligned=True))
  cov[i:M, i] = cov[i, i:M] = data[:, i] @ data[:, i:M] / (float_n - 1.0)
/hppfs/work/pr28fi/di38jil/npb-shared/npb-lrz/npbench/benchmarks/polybench/covariance/covariance_numba_opr.py:5: NumbaWarning: 
Compilation is falling back to object mode WITHOUT looplifting enabled because Function "kernel" failed type inference due to: non-precise type pyobject
During: typing of argument at /hppfs/work/pr28fi/di38jil/npb-shared/npb-lrz/npbench/benchmarks/polybench/covariance/covariance_numba_opr.py (16)

File "../../../npbench/benchmarks/polybench/covariance/covariance_numba_opr.py", line 16:
def kernel(M, float_n, data):
    <source elided>
    #         cov[j, i] = cov[i, j]
    for i in nb.prange(M):
    ^

  @nb.jit(nopython=False, forceobj=True, parallel=True, fastmath=True)
/hppfs/work/pr28fi/di38jil/npb-shared/npb-lrz/npbench/benchmarks/polybench/covariance/covariance_numba_n.py:18: NumbaPerformanceWarning: '@' is faster on contiguous arrays, called on (Array(float64, 1, 'A', False, aligned=True), Array(float64, 2, 'A', False, aligned=True))
  cov[i:M, i] = cov[i, i:M] = data[:, i] @ data[:, i:M] / (float_n - 1.0)
/hppfs/work/pr28fi/di38jil/npb-shared/npb-lrz/npbench/benchmarks/polybench/covariance/covariance_numba_np.py:18: NumbaPerformanceWarning: '@' is faster on contiguous arrays, called on (Array(float64, 1, 'A', False, aligned=True), Array(float64, 2, 'A', False, aligned=True))
  cov[i:M, i] = cov[i, i:M] = data[:, i] @ data[:, i:M] / (float_n - 1.0)
